// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0

#ifndef GWLBTUN_UTILS_H
#define GWLBTUN_UTILS_H

#include <iostream>
#include <iomanip>
#include <cctype>
#include <string>
#include <memory>
#include <stdexcept>
#include <cstdarg>  // For va_start, etc.
#include <chrono>
#include <vector>
#include <algorithm>
#include "GenevePacket.h"   // For eniid_t

using namespace std::string_literals;

// Version information is now in version.h (auto-generated by CMake)
#include "version.h"

// Fix for versions of GLBIC prior to 2.30 where gettid() was added.
#if defined(__GLIBC__) && (__GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 30))
#include <sys/syscall.h>
#include <unistd.h>
#define gettid() syscall(SYS_gettid)
#endif

// If only decapsulation is required, i.e. you will never send traffic back to GWLB via the local interfaces,
// you can define the following symbol to improve performance (GWLBTun no longer needs to track flow cookies, etc.)
//#define NO_RETURN_TRAFFIC

// Thread configuration parser and data struct
#define MAX_THREADS    128
typedef struct ThreadConfigStruct {
    std::vector<int> cfg;
} ThreadConfig;

std::string stringFormat(const std::string& fmt_str, ...);
std::string stringFormat(const std::string& fmt_str, va_list ap);
bool sendUdpSG(int sock, struct in_addr from_addr, uint16_t from_port, struct in_addr to_addr, uint16_t to_port, const struct iovec *payload_iov, int payload_iovcnt);
std::string toBase60(uint64_t val);
std::string timepointDeltaString(std::chrono::steady_clock::time_point t1, std::chrono::steady_clock::time_point t2);
double timepointDeltaDouble(std::chrono::steady_clock::time_point t1, std::chrono::steady_clock::time_point t2);
std::string sockaddrToName(struct sockaddr *sa);
void ParseThreadConfiguration(int threadcount, std::string& affinity, ThreadConfig *dest);
std::string MakeENIStr(eniid_t eni);
int FindIndexOf(std::vector<std::string> vector, std::string search);

// If hashFunc is a function that does not result in the same hash for both flow directions,
// #undef the next line so that GeneveHandler and PacketHeader changes their logic appropriately.
#define HASH_IS_SYMMETRICAL
/**
 * Simple, basic, but very fast hash function.  Returns same hash in both directions, so leave HASH_IS_SYMMETRICAL
 * defined.
 * @param prot    Protocol number
 * @param srcip   Pointer to source IP data
 * @param dstip   Pointer to destination IP data
 * @param ipsize  Size of IP data (4 for IPv4, 16 for IPv6)
 * @param srcpt   Source Port Number
 * @param dstpt   Destination Port NUmber
 * @return
 */
inline size_t hashFunc(uint8_t prot, void *srcip, void *dstip, int ipsize, uint16_t srcpt, uint16_t dstpt)
{
    uint32_t *srciplongs = (uint32_t *)srcip;
    uint32_t *dstiplongs = (uint32_t *)dstip;
    
    // Use XOR and bit rotation for better distribution while maintaining symmetry
    size_t hash = prot;
    
    if(ipsize == 4)
    {
        // Rotate and XOR for IPv4 - still symmetric
        uint32_t ip_mix = srciplongs[0] ^ dstiplongs[0];
        hash ^= (ip_mix << 7) | (ip_mix >> 25);  // Rotate left 7
        hash ^= (srciplongs[0] + dstiplongs[0]) * 0x9e3779b1;  // Golden ratio mixing
    } else {
        // IPv6 - XOR all components with rotation
        uint32_t ip_mix = srciplongs[0] ^ srciplongs[1] ^ srciplongs[2] ^ srciplongs[3] ^
                          dstiplongs[0] ^ dstiplongs[1] ^ dstiplongs[2] ^ dstiplongs[3];
        hash ^= (ip_mix << 13) | (ip_mix >> 19);  // Rotate left 13
        hash ^= ip_mix * 0x9e3779b1;
    }
    
    // Mix in ports symmetrically
    uint32_t port_mix = srcpt ^ dstpt;
    hash ^= (port_mix << 16) | (srcpt + dstpt);
    
    return hash;
}

/**
 * Case-insensitive iterable thing search
 *
 * @param iter     Iterable to search through
 * @param search   Search string
 * @return Index in vector of string case-insensitive, or -1 if not found.
 */
template <class X> int FindIndexOf(X iter, std::string search)
{
    int ret = 0;

    std::string searchLower = search;
    std::transform(searchLower.begin(), searchLower.end(), searchLower.begin(), [](unsigned char c){return std::tolower(c); });

    for(auto it = iter.begin(); it != iter.end(); it++, ret++)
        if(*it == searchLower)
            return ret;

    return -1;
}

#endif //GWLBTUN_UTILS_H
